---
title: "Circular Visulaization in R: Chapter 1"
author: "Lorene Stasiuk"
date: "11/2/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Chapter 1: Introduction

##### Circos is a pioneer tool widely used for circular layout representations implemented in Perl. Here the circlize package aims to implement Circos in R. One important advantage for the implementation in R is that R is an ideal environment which provides seamless connection between data analysis and data visualization. In this book, chapters in Part I give detailed overviews of the general circlize functionalities. Part II introduces functions specifically designed for visualizing genomic datasets. Part III gives comprehensive guilds on visualizing relationships by Chord diagram.

## 1.1 Principle of design

```{r, intro}
# A circular layout is composed of sectors and tracks.The intersection of a sector and a track is called a cell (or a grid, a panel), which is the basic unit in a circular layout. It is an imaginary plotting region for drawing data points.

# circlize implements low-level graphic functions for adding graphics in the circular plotting regions, so that more complicated graphics can be easily generated by different combinations of low-level graphic functions.

# Currently there are following low-level graphic functions that can be used for adding graphics.

# circos.points(): adds points in a cell.
# circos.lines(): adds lines in a cell.
# circos.segments(): adds segments in a cell.
# circos.rect(): adds rectangles in a cell.
# circos.polygon(): adds polygons in a cell.
# circos.text(): adds text in a cell.
# circos.axis() ands circos.yaxis(): add axis in a cell.


# Following function draws links between two positions in the circle:

# circos.link()


#Following functions draw high-level graphics:

# circos.barplot(): draw barplots.
# circos.boxplot(): draw boxplots.
# circos.violin(): draws violin plots.
# circos.heatmap(): draw circular heatmaps.
# circos.raster(): draw raster images.
# circos.arrow(): draw circular arrows.


# Following functions arrange the circular layout.

# circos.initialize(): allocates sectors on the circle.
# circos.track(): creates plotting regions for cells in one single track.
# circos.update(): updates an existed cell.
# circos.par(): graphic parameters.
# circos.info(): prints general parameters of current circular plot.
# circos.clear(): resets graphic parameters and internal variables.
```

# 1.2 A Quick Glance
```{r, circlize1}
# Basic functionalities in the circlize package

# generate random data
set.seed(999)
n = 1000
df = data.frame(sectors = sample(letters[1:8], n, replace = TRUE),
    x = rnorm(n), y = runif(n))

# First we initialize the circular layout. The circle is split into sectors based on the data range on x-axes in each category. Be default, sectors are positioned started from θ=0 (in the polar coordinate system) and go along the circle clock-wisely.

library("circlize")
circos.par("track.height" = 0.1)
circos.initialize(df$sectors, x = df$x)

# We set a global parameter track.height to 0.1 by the option function circis.par() so that all tracks which will be added have a default height of 0.1.

# After the circular layout is initialized, graphics can be added to the plot in a track-by-track manner. 

circos.track(df$sectors, y = df$y,
    panel.fun = function(x, y) {
        circos.text(CELL_META$xcenter, 
            CELL_META$cell.ylim[2] + mm_y(5), 
            CELL_META$sector.index)
        circos.axis(labels.cex = 0.6)
})
col = rep(c("#FF0000", "#00FF00"), 4)
circos.trackPoints(df$sectors, df$x, df$y, col = col, pch = 16, cex = 0.5)
circos.text(-1, 0.5, "text", sector.index = "a", track.index = 1)
```

```{r, track2_histogram}
# We repeat the above steps so we can add histograms to the second track.

# generate random data
set.seed(999)
n = 1000
df = data.frame(sectors = sample(letters[1:8], n, replace = TRUE),
    x = rnorm(n), y = runif(n))

# First we initialize the circular layout. The circle is split into sectors based on the data range on x-axes in each category. Be default, sectors are positioned started from θ=0 (in the polar coordinate system) and go along the circle clock-wisely.

circos.par("track.height" = 0.1)
circos.initialize(df$sectors, x = df$x)

# We set a global parameter track.height to 0.1 by the option function circis.par() so that all tracks which will be added have a default height of 0.1.

# After the circular layout is initialized, graphics can be added to the plot in a track-by-track manner. 

circos.track(df$sectors, y = df$y,
    panel.fun = function(x, y) {
        circos.text(CELL_META$xcenter, 
            CELL_META$cell.ylim[2] + mm_y(5), 
            CELL_META$sector.index)
        circos.axis(labels.cex = 0.6)
})
col = rep(c("#FF0000", "#00FF00"), 4)
circos.trackPoints(df$sectors, df$x, df$y, col = col, pch = 16, cex = 0.5)
circos.text(-1, 0.5, "text", sector.index = "a", track.index = 1)

# Now we add histograms to the second track. Here circos.trackHist() is a high-level function which means it creates a new track. bin.size is explicitly set so that the bin size for histograms in all cells are the same and can be compared to each other.

# NEW CODE
bgcol = rep(c("#EFEFEF", "#CCCCCC"), 4)
circos.trackHist(df$sectors, df$x, bin.size = 0.2, bg.col = bgcol, col = NA)
```

```{r, track3_sort}
# Again repeating the above steps, we add a third track that sorts randomly picked data points from each cell.

# generate random data
set.seed(999)
n = 1000
df = data.frame(sectors = sample(letters[1:8], n, replace = TRUE),
    x = rnorm(n), y = runif(n))

# First we initialize the circular layout. The circle is split into sectors based on the data range on x-axes in each category. Be default, sectors are positioned started from θ=0 (in the polar coordinate system) and go along the circle clock-wisely.

circos.par("track.height" = 0.1)
circos.initialize(df$sectors, x = df$x)

# We set a global parameter track.height to 0.1 by the option function circis.par() so that all tracks which will be added have a default height of 0.1.

# After the circular layout is initialized, graphics can be added to the plot in a track-by-track manner. 

circos.track(df$sectors, y = df$y,
    panel.fun = function(x, y) {
        circos.text(CELL_META$xcenter, 
            CELL_META$cell.ylim[2] + mm_y(5), 
            CELL_META$sector.index)
        circos.axis(labels.cex = 0.6)
})
col = rep(c("#FF0000", "#00FF00"), 4)
circos.trackPoints(df$sectors, df$x, df$y, col = col, pch = 16, cex = 0.5)
circos.text(-1, 0.5, "text", sector.index = "a", track.index = 1)

# Now we add histograms to the second track. Here circos.trackHist() is a high-level function which means it creates a new track. bin.size is explicitly set so that the bin size for histograms in all cells are the same and can be compared to each other.

bgcol = rep(c("#EFEFEF", "#CCCCCC"), 4)
circos.trackHist(df$sectors, df$x, bin.size = 0.2, bg.col = bgcol, col = NA)

# In the third track and in panel.fun, we randomly picked 10 data points in each cell, sort them by x-values and connect them with lines.

# NEW CODE
circos.track(df$sectors, x = df$x, y = df$y,
    panel.fun = function(x, y) {
        ind = sample(length(x), 10)
        x2 = x[ind]
        y2 = y[ind]
        od = order(x2)
        circos.lines(x2[od], y2[od])
})
```


```{r, track2_update}
# The function, circos.update(), erases graphics which have been added. circos.update() can not modify the xlim and ylim of the cell as well as other settings related to the position of the cell.


# generate random data
set.seed(999)
n = 1000
df = data.frame(sectors = sample(letters[1:8], n, replace = TRUE),
    x = rnorm(n), y = runif(n))

# First we initialize the circular layout. The circle is split into sectors based on the data range on x-axes in each category. Be default, sectors are positioned started from θ=0 (in the polar coordinate system) and go along the circle clock-wisely.

circos.par("track.height" = 0.1)
circos.initialize(df$sectors, x = df$x)

# We set a global parameter track.height to 0.1 by the option function circis.par() so that all tracks which will be added have a default height of 0.1.

# After the circular layout is initialized, graphics can be added to the plot in a track-by-track manner. 

circos.track(df$sectors, y = df$y,
    panel.fun = function(x, y) {
        circos.text(CELL_META$xcenter, 
            CELL_META$cell.ylim[2] + mm_y(5), 
            CELL_META$sector.index)
        circos.axis(labels.cex = 0.6)
})
col = rep(c("#FF0000", "#00FF00"), 4)
circos.trackPoints(df$sectors, df$x, df$y, col = col, pch = 16, cex = 0.5)
circos.text(-1, 0.5, "text", sector.index = "a", track.index = 1)

# Now we add histograms to the second track. Here circos.trackHist() is a high-level function which means it creates a new track. bin.size is explicitly set so that the bin size for histograms in all cells are the same and can be compared to each other.

bgcol = rep(c("#EFEFEF", "#CCCCCC"), 4)
circos.trackHist(df$sectors, df$x, bin.size = 0.2, bg.col = bgcol, col = NA)

# In the third track and in panel.fun, we randomly picked 10 data points in each cell, sort them by x-values and connect them with lines.

circos.track(df$sectors, x = df$x, y = df$y,
    panel.fun = function(x, y) {
        ind = sample(length(x), 10)
        x2 = x[ind]
        y2 = y[ind]
        od = order(x2)
        circos.lines(x2[od], y2[od])
})

# NEW CODE
circos.update(sector.index = "d", track.index = 2, 
    bg.col = "#FF8080", bg.border = "black")
circos.points(x = -2:2, y = rep(0.5, 5), col = "white")
circos.text(CELL_META$xcenter, CELL_META$ycenter, "updated", col = "white")

```

```{r, track4_heatmap}
# Again repeating the above steps, we add another track, a heat map, using circos.rect().

# generate random data
set.seed(999)
n = 1000
df = data.frame(sectors = sample(letters[1:8], n, replace = TRUE),
    x = rnorm(n), y = runif(n))

# First we initialize the circular layout. The circle is split into sectors based on the data range on x-axes in each category. Be default, sectors are positioned started from θ=0 (in the polar coordinate system) and go along the circle clock-wisely.

circos.par("track.height" = 0.1)
circos.initialize(df$sectors, x = df$x)

# We set a global parameter track.height to 0.1 by the option function circis.par() so that all tracks which will be added have a default height of 0.1.

# After the circular layout is initialized, graphics can be added to the plot in a track-by-track manner. 

circos.track(df$sectors, y = df$y,
    panel.fun = function(x, y) {
        circos.text(CELL_META$xcenter, 
            CELL_META$cell.ylim[2] + mm_y(5), 
            CELL_META$sector.index)
        circos.axis(labels.cex = 0.6)
})
col = rep(c("#FF0000", "#00FF00"), 4)
circos.trackPoints(df$sectors, df$x, df$y, col = col, pch = 16, cex = 0.5)
circos.text(-1, 0.5, "text", sector.index = "a", track.index = 1)

# Now we add histograms to the second track. Here circos.trackHist() is a high-level function which means it creates a new track. bin.size is explicitly set so that the bin size for histograms in all cells are the same and can be compared to each other.

bgcol = rep(c("#EFEFEF", "#CCCCCC"), 4)
circos.trackHist(df$sectors, df$x, bin.size = 0.2, bg.col = bgcol, col = NA)

# In the third track and in panel.fun, we randomly picked 10 data points in each cell, sort them by x-values and connect them with lines.

circos.track(df$sectors, x = df$x, y = df$y,
    panel.fun = function(x, y) {
        ind = sample(length(x), 10)
        x2 = x[ind]
        y2 = y[ind]
        od = order(x2)
        circos.lines(x2[od], y2[od])
})

circos.update(sector.index = "d", track.index = 2, 
    bg.col = "#FF8080", bg.border = "black")
circos.points(x = -2:2, y = rep(0.5, 5), col = "white")
circos.text(CELL_META$xcenter, CELL_META$ycenter, "updated", col = "white")

# NEW CODE
circos.track(ylim = c(0, 1), panel.fun = function(x, y) {
    xlim = CELL_META$xlim
    ylim = CELL_META$ylim
    breaks = seq(xlim[1], xlim[2], by = 0.1)
    n_breaks = length(breaks)
    circos.rect(breaks[-n_breaks], rep(ylim[1], n_breaks - 1),
                breaks[-1], rep(ylim[2], n_breaks - 1),
                col = rand_color(n_breaks), border = NA)
})
```

```{r, tracklink}
# In the most inside of the circle, links or ribbons are added. There can be links from single point to point, point to interval or interval to interval. 

# Repeating above steps, we can add links to the inside circle

# generate random data
set.seed(999)
n = 1000
df = data.frame(sectors = sample(letters[1:8], n, replace = TRUE),
    x = rnorm(n), y = runif(n))

# First we initialize the circular layout. The circle is split into sectors based on the data range on x-axes in each category. Be default, sectors are positioned started from θ=0 (in the polar coordinate system) and go along the circle clock-wisely.

circos.par("track.height" = 0.1)
circos.initialize(df$sectors, x = df$x)

# We set a global parameter track.height to 0.1 by the option function circis.par() so that all tracks which will be added have a default height of 0.1.

# After the circular layout is initialized, graphics can be added to the plot in a track-by-track manner. 

circos.track(df$sectors, y = df$y,
    panel.fun = function(x, y) {
        circos.text(CELL_META$xcenter, 
            CELL_META$cell.ylim[2] + mm_y(5), 
            CELL_META$sector.index)
        circos.axis(labels.cex = 0.6)
})
col = rep(c("#FF0000", "#00FF00"), 4)
circos.trackPoints(df$sectors, df$x, df$y, col = col, pch = 16, cex = 0.5)
circos.text(-1, 0.5, "text", sector.index = "a", track.index = 1)

# Now we add histograms to the second track. Here circos.trackHist() is a high-level function which means it creates a new track. bin.size is explicitly set so that the bin size for histograms in all cells are the same and can be compared to each other.

bgcol = rep(c("#EFEFEF", "#CCCCCC"), 4)
circos.trackHist(df$sectors, df$x, bin.size = 0.2, bg.col = bgcol, col = NA)

# In the third track and in panel.fun, we randomly picked 10 data points in each cell, sort them by x-values and connect them with lines.

circos.track(df$sectors, x = df$x, y = df$y,
    panel.fun = function(x, y) {
        ind = sample(length(x), 10)
        x2 = x[ind]
        y2 = y[ind]
        od = order(x2)
        circos.lines(x2[od], y2[od])
})

circos.update(sector.index = "d", track.index = 2, 
    bg.col = "#FF8080", bg.border = "black")
circos.points(x = -2:2, y = rep(0.5, 5), col = "white")
circos.text(CELL_META$xcenter, CELL_META$ycenter, "updated", col = "white")

circos.track(ylim = c(0, 1), panel.fun = function(x, y) {
    xlim = CELL_META$xlim
    ylim = CELL_META$ylim
    breaks = seq(xlim[1], xlim[2], by = 0.1)
    n_breaks = length(breaks)
    circos.rect(breaks[-n_breaks], rep(ylim[1], n_breaks - 1),
                breaks[-1], rep(ylim[2], n_breaks - 1),
                col = rand_color(n_breaks), border = NA)
})

# NEW CODE
circos.link("a", 0, "b", 0, h = 0.4)
circos.link("c", c(-0.5, 0.5), "d", c(-0.5,0.5), col = "red",
    border = "green", h = 0.2)
circos.link("e", 0, "g", c(-1,1), col = "pink", border = "black", lwd = 2, lty = 2)

```

```{r, clearing}
# Finally we need to reset the graphic parameters and internal variables, so that it will not mess up your next plot.


circos.clear()

```

